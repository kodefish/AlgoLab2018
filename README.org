* Algorithms Lab 2019
This repo contains my solutions to the algorithms lab of ETH ZÃ¼rich. The lab consists of problems every week that must be solved via an algorithm. 

** Overview
|   Week | Problem                 |     Score | Solution                                                                  |
|--------+-------------------------+-----------+---------------------------------------------------------------------------|
|      1 | Even Pairs              |       100 | Partial Sums                                                              |
|      1 | Build The Sum           |       100 | Common Sense                                                              |
|      1 | Dominoes                |       100 | Sliding over the dominoes                                                 |
|      1 | Even Matrices           |       100 | Precomputation and reducing to even pairs                                 |
| PotW 1 | Deck of Cards           |       100 | Precomputation + sliding window                                           |
|      2 | Burning Coins           |       100 | Dynamic Programming                                                       |
|      2 | Beach Bars              |       100 | Sliding Windowm                                                           |
|      2 | The Great Game          |       100 | Dynamic Programming                                                       |
|      2 | Search Snippets         |       100 | Sliding Window + sets of words for efficient min/max                      |
| PotW 2 | From Russia With Love   |       100 | Generalized version of Burning Coins -> Top-down DP                       |
|      3 | Hit                     |       100 | CGAL intersection testing                                                 |
|      3 | First Hit               |       100 | CGAL intersection testing + adversarial input mitigation (random shuffle) |
|      3 | Antenna                 |       100 | CGAL Min Circle                                                           |
|      3 | Almost Antenna          |       100 | CGAL Min Circle and Support Points                                        |
| PotW 3 | Chariot Race            |     80/80 |                                                                           |
|      4 | First Steps with BGL    |       100 | Basic BGL intro (MST and Dijkstra shortest path)                          |
|      4 | Ant Challenge           |       100 | Multiple MST and shortest path                                            |
|      4 | Buddy Selection         |       100 | Maximum Cardinality matching                                              |
|      4 | Shortest Paths          |       100 | Dijkstra                                                                  |
| Potw 4 | Motorcycles             |       100 | CGAL Intersections, slope logic, stack tracking and bottom up weird magic |
|      5 | Boats                   |       100 | Greedy Algorithm                                                          |
|      5 | Light at the Museum     |       100 | Split & List                                                              |
|      5 | Octopussy               |       100 | Greedy Algorithm                                                          |
| Potw 5 | Planet Express          |     80/80 | Shortest paths and vertex aggregation                                     |
|      6 | Coin Tossing Tournament |       100 | Max flow                                                                  |
|--------+-------------------------+-----------+---------------------------------------------------------------------------|
|        | total                   | 2100/2480 | A lot of time.                                                            |


** Compilation and Running
*** STL/BGL Files
To compile the cpp files:
#+BEGIN_SRC bash
g++ -Wall -O3 filename.cpp -o filename.o
#+END_SRC

To run the file with a given input and redirect output to a file
#+BEGIN_SRC bash
./filename.o < testsets/test{i}.in > test{i}.out
#+END_SRC

To compare with the expected output, use `diff`
#+BEGIN_SRC bash
diff test{i}.out testsets/test{i}.out
#+END_SRC

Alternatively, you can do the previous in one line
#+BEGIN_SRC bash
diff <(./filename.o < testsets/test{i}.in) testsets/test{i}.out
#+END_SRC

*** CGAL
Compiling CGAL files is slightly different, it makes use of the ~cgal_create_cmake_script~.
In order to avoid to seperate the source code from compiled files, take advantage of an additional build folder.
Compile as follows:
#+BEGIN_SRC bash
cgal_create_cmake_script
mkdir build && cd build
cmake ..
make
#+END_SRC

To run, the procedure is the same as for STL/BGL files.

** Tips & Tricks
*** Adversarial Input
- Input may be given in an adversarial way, in order to maximize
  comparisions/operations. To avoid this, if the input order _does not matter_,
  then ~std::random_shuffle~ is /always/ a good idea.
*** Dynamic Programming
1. When using multidimensional arrays, always keep the lowest dimensionality as
   the first dimension. For some reason, this increases speed enough to go from
   *TL* to *OK*. This proves handy in DP programs for memoization
2. Memoization: Carefully think about what is required to be placed in the
   memoization. Think about if the dimensionality can be reduced (e.g. as in
   Russia, reducing to two behaviours, minimizing and maximizing).
3. *Carefully* consider all the cases when writing a DP recurrence. E.g.
   =Chariot Race= had three distinct cases to consider, and you must very
   carefully think about each one.
4. DP can carry information from above (e.g. in the tree scenario, information
   about the parent node may be useful). A sub-problem is not necessarily
   separated from the rest.

*** CPP
- Set intersection of ~std::set~ can be done using ~std::set_intersection~ (included in ~algorithm~). The following code computes the intersection between 2 sets and stores the result in the ~intersection~ vector. You can also use a ~std::set~ to store the result, but ~std::back_inserter~ may complain about something or other.
  #+BEGIN_SRC cpp
#include <algorithm>
std::set<int> set1, set2;
std::vector<int> intersection;
std::set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), std::back_inserter(intersection));
  #+END_SRC
- Priority queue (~std::priority_queue~ found in ~queue.h~) let's us keep and
  ordred stack (ordering is preserved through insertion). If using pairs
  (~std::pair~), by default they will be ordred based on the first element of
  the pair.
  #+BEGIN_SRC cpp
#include <queue>
// By default, priority queue orders in decreasing order
std::priority_queue<int> q1;
// Use this to sort in ascending order
std::priority_queue<int, std::vector<int>, std::greater<int>> q2;

// Push, top an pop are the main useful ones
q1.push(1);
int t = q1.top();
q1.pop();
  #+END_SRC
*** CGAL
- Reading input directly into a ~std::vector~ and letting the compiler infer the
  construction is much slower than reading it in, constructing it yourself and
  then pushing it into the array.
  - Faster:
      #+BEGIN_SRC cpp
std::vector<Construction> list(n);
for(int i = 0; i < n; i++) {
    long x, y; std::cin >> x >> y;
    Construction z(x, y);
    list[i] = z;
}
      #+END_SRC
  - Slower:
      #+BEGIN_SRC cpp
std::vector<Construction> list(n);
for(int i = 0; i < n; i++) {
    std::cin >> list[i];
}
      #+END_SRC
- You can keep track of multiple variables using a =struct=, this can be used to
  avoid having a bunch of different =vectors=. You just need to provide a
  comparison function
  #+BEGIN_SRC cpp
struct Wrapper {
    long x, y, z;

    bool operator<(const Wrapper& t) const { return this->x < t.x; }
}

std::vector<Wrapper> vec;
vec.push_back(Wrapper{x, y, z});
  #+END_SRC
*** BGL
- Weight maps are linked to a graph, so a graph can only have one weight map. So
  basically you cannot make one graph with mulitple weight maps, you need to
  have one graph per weight map.
*** Split & List
You can use ~std::map~ and use ~find()~ to search for specific keys. It is
logarithmic, so no need to implement some binary search yourself, just use the
STL.
#+BEGIN_SRC cpp
std::map<int, int> s1, s2;
for(auto s1_itr : s1) {
    // Compute the key
    auto key = smth - s1.first;
    auto s2_itr = s2.find(key);
    if (s2_itr != s2.end()) {
        // key exists! so do something
    }
}
#+END_SRC
