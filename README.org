* Algorithms Lab 2019
This repo contains my solutions to the algorithms lab of ETH ZÃ¼rich. The lab consists of problems every week that must be solved via an algorithm. 

** Overview
|   Week | Problem                 |     Score | Solution                                                                  |
|--------+-------------------------+-----------+---------------------------------------------------------------------------|
|      1 | Even Pairs              |       100 | Partial Sums                                                              |
|      1 | Build The Sum           |       100 | Common Sense                                                              |
|      1 | Dominoes                |       100 | Sliding over the dominoes                                                 |
|      1 | Even Matrices           |       100 | Precomputation and reducing to even pairs                                 |
| PotW 1 | Deck of Cards           |       100 | Precomputation + sliding window                                           |
|      2 | Burning Coins           |       100 | Dynamic Programming                                                       |
|      2 | Beach Bars              |       100 | Sliding Windowm                                                           |
|      2 | The Great Game          |       100 | Dynamic Programming                                                       |
|      2 | Search Snippets         |       100 | Sliding Window + sets of words for efficient min/max                      |
| PotW 2 | From Russia With Love   |       100 | Generalized version of Burning Coins -> Top-down DP                       |
|      3 | Hit                     |       100 | CGAL intersection testing                                                 |
|      3 | First Hit               |       100 | CGAL intersection testing + adversarial input mitigation (random shuffle) |
|      3 | Antenna                 |       100 | CGAL Min Circle                                                           |
|      3 | Almost Antenna          |       100 | CGAL Min Circle and Support Points                                        |
| PotW 3 | Chariot Race            |     80/80 |                                                                           |
|      4 | First Steps with BGL    |       100 | Basic BGL intro (MST and Dijkstra shortest path)                          |
|      4 | Ant Challenge           |       100 | Multiple MST and shortest path                                            |
|      4 | Buddy Selection         |       100 | Maximum Cardinality matching                                              |
|      4 | Shortest Paths          |       100 | Dijkstra                                                                  |
| Potw 4 | Motorcycles             |       100 | CGAL Intersections, slope logic, stack tracking and bottom up weird magic |
|      5 | Boats                   |       100 | Greedy Algorithm                                                          |
|      5 | Light at the Museum     |       100 | Split & List                                                              |
|      5 | Octopussy               |       100 | Greedy Algorithm                                                          |
| Potw 5 | Planet Express          |     80/80 | Shortest paths and vertex aggregation                                     |
|      6 | Coin Tossing Tournament |       100 | Max flow                                                                  |
|      6 | Shopping Trip           |       100 | Max flow                                                                  |
|      6 | Tetris                  |       100 | Max flow and vertex capacity                                              |
|      6 | London                  |       100 | Max flow and vertex aggregation                                           |
| Potw 6 | Attack of the Clones    |         0 | -                                                                         |
|      7 | Maximize It             |       100 | LP                                                                        |
|      7 | Diet                    |       100 | LP                                                                        |
|      7 | Inball                  |       100 | LP + some highschool maths                                                |
|      7 | Radiation               |       100 | LP + Binary Search                                                        |
| Potw 7 | Cantonal Courier        |         0 | -                                                                         |
|      8 | Graypes                 |       100 | Delaunay Triangulation                                                    |
|      8 | Bistro                  |       100 | Delaunay Triangulation                                                    |
|      8 | Germs                   |       100 | Delaunay Triangulation                                                    |
|      8 | Germs                   |        80 | Delaunay Triangulation + iterative DFS                                    |
| PotW 8 | Suez                    |       100 | LP                                                                        |
|      9 | Satellites              |       100 | Minimal vertex cover                                                      |
|      9 | Algocoon Group          |       100 | MinCut MaxFlow                                                            |
|      9 | Canteen                 |       100 | MinCost Max Flow + transforming negative weights into positive            |
| PotW 9 | GoldenEye               |       100 | Delaunay Triangulation + Union Find                                       |
|     10 | Return of the Jedi      |       100 | MST + voodoo black magic                                                  |
|     10 | Light the Stage         |       100 | Delaunay Triangulation                                                    |
|--------+-------------------------+-----------+---------------------------------------------------------------------------|
|        | total                   | 2100/2480 | A lot of time.                                                            |


** Compilation and Running
*** STL/BGL Files
To compile the cpp files:
#+BEGIN_SRC bash
g++ -Wall -O3 filename.cpp -o filename.o
#+END_SRC

To run the file with a given input and redirect output to a file
#+BEGIN_SRC bash
./filename.o < testsets/test{i}.in > test{i}.out
#+END_SRC

To compare with the expected output, use `diff`
#+BEGIN_SRC bash
diff test{i}.out testsets/test{i}.out
#+END_SRC

Alternatively, you can do the previous in one line
#+BEGIN_SRC bash
diff <(./filename.o < testsets/test{i}.in) testsets/test{i}.out
#+END_SRC

*** CGAL
Compiling CGAL files is slightly different, it makes use of the ~cgal_create_cmake_script~.
In order to avoid to seperate the source code from compiled files, take advantage of an additional build folder.
Compile as follows:
#+BEGIN_SRC bash
cgal_create_cmake_script
mkdir build && cd build
cmake ..
make
#+END_SRC

To run, the procedure is the same as for STL/BGL files.

** Tips & Tricks
*** Adversarial Input
- Input may be given in an adversarial way, in order to maximize
  comparisions/operations. To avoid this, if the input order _does not matter_,
  then ~std::random_shuffle~ is /always/ a good idea.
*** Dynamic Programming
1. When using multidimensional arrays, always keep the lowest dimensionality as
   the first dimension. For some reason, this increases speed enough to go from
   *TL* to *OK*. This proves handy in DP programs for memoization
2. Memoization: Carefully think about what is required to be placed in the
   memoization. Think about if the dimensionality can be reduced (e.g. as in
   Russia, reducing to two behaviours, minimizing and maximizing).
3. *Carefully* consider all the cases when writing a DP recurrence. E.g.
   =Chariot Race= had three distinct cases to consider, and you must very
   carefully think about each one.
4. DP can carry information from above (e.g. in the tree scenario, information
   about the parent node may be useful). A sub-problem is not necessarily
   separated from the rest.

*** CPP
- Set intersection of ~std::set~ can be done using ~std::set_intersection~ (included in ~algorithm~). The following code computes the intersection between 2 sets and stores the result in the ~intersection~ vector. You can also use a ~std::set~ to store the result, but ~std::back_inserter~ may complain about something or other.
  #+BEGIN_SRC cpp
#include <algorithm>
std::set<int> set1, set2;
std::vector<int> intersection;
std::set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), std::back_inserter(intersection));
  #+END_SRC
- Priority queue (~std::priority_queue~ found in ~queue.h~) let's us keep and
  ordred stack (ordering is preserved through insertion). If using pairs
  (~std::pair~), by default they will be ordred based on the first element of
  the pair.
  #+BEGIN_SRC cpp
#include <queue>
// By default, priority queue orders in decreasing order
std::priority_queue<int> q1;
// Use this to sort in ascending order
std::priority_queue<int, std::vector<int>, std::greater<int>> q2;

// Push, top an pop are the main useful ones
q1.push(1);
int t = q1.top();
q1.pop();
  #+END_SRC
*** CGAL
- Reading input directly into a ~std::vector~ and letting the compiler infer the
  construction is much slower than reading it in, constructing it yourself and
  then pushing it into the array.
  - Faster:
      #+BEGIN_SRC cpp
std::vector<Construction> list(n);
for(int i = 0; i < n; i++) {
    long x, y; std::cin >> x >> y;
    Construction z(x, y);
    list[i] = z;
}
      #+END_SRC
  - Slower:
      #+BEGIN_SRC cpp
std::vector<Construction> list(n);
for(int i = 0; i < n; i++) {
    std::cin >> list[i];
}
      #+END_SRC
- You can keep track of multiple variables using a =struct=, this can be used to
  avoid having a bunch of different =vectors=. You just need to provide a
  comparison function
  #+BEGIN_SRC cpp
struct Wrapper {
    long x, y, z;

    bool operator<(const Wrapper& t) const { return this->x < t.x; }
}

std::vector<Wrapper> vec;
vec.push_back(Wrapper{x, y, z});
  #+END_SRC
- LP: Double check your inequalities and constraints. 90% of mistakes come from
  there. Check that you have added all the lower and upper bounds you need (for
  example a radius cannot be less than 0).
- You can implement ~ceil_to_double(x)~ by just calling ~-floor_to_double(-x)~.
  You can find the implementation for ~floor_to_double~ on the judge, in the
  ~hello-exact.cpp~ sample code. This saves you time in not having to rewrite
  the function and ensures you don't make any typos, as that particular function
  is very typo-prone.
- You can store information in vertices/faces when using Delaunay
  Triangulations. This is especially useful if you want to avoid using ~map~ to
  ~Vertex_handle~ or ~Face_hanlde~. The syntax is as follows:
  #+BEGIN_SRC cpp
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Exact_predicates_exact_constructions_kernel_with_sqrt.h>
#include <CGAL/Triangulation_data_structure_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <CGAL/Delaunay_triangulation_2.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel IK;
typedef CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt EK;
// Define the kind of information to store in the vertex here
typedef CGAL::Triangulation_vertex_base_with_info_2<IK::FT,IK> vertex_t;
typedef CGAL::Triangulation_face_base_2<IK> face_t;
typedef CGAL::Triangulation_data_structure_2<vertex_t,face_t> triangulation_t;
typedef CGAL::Delaunay_triangulation_2<IK,triangulation_t> delaunay_t;

Vertex_handle e;
e->info() = 42;
  #+END_SRC
- Adding to the previous point, you can directly init the info of a vertex by passing the
  insert method a ~std::vector<std::pair<K::Point_2, int>>~.
  #+BEGIN_SRC cpp
    std::vector<std::pair<K::Point_2, int>> pts;
    pts.reserve(n);
    for (std::size_t i = 0; i < n; ++i) {
        K::Point_2 pt;
        std::cin >> pt;
        pts.push_back(std::make_pair(pt, i));
    }

    // construct triangulation
    Triangulation t;
    t.insert(pts.begin(), pts.end());
  #+END_SRC
 
*** BGL
- Weight maps are linked to a graph, so a graph can only have one weight map. So
  basically you cannot make one graph with mulitple weight maps, you need to
  have one graph per weight map.
- Try to keep the amount of vertices to a minimum. Try to see if you can aggregate or use
  some sort of "hub".
- The sample code on the judge contains the code for a minimal vertex cover, and
  as a bonus it also contains a BFS implementation, should you need inspiration
  for one at some point (like in H1N1 wink wink).
- If you have negative weights, you can figure out the max weight, and make all
  your weights positve by replacing ~-cost~ with ~MAX_COST - cost~. Then you
  have to adjust for it later, when computing the final cost with
  ~cost = (MAX_COST * flow) - cost~.
- You can use BGL's ~<boost/pending/disjoint_sets.hpp>~ as an implementation of union
  set.
  #+BEGIN_SRC cpp
#include <boost/pending/disjoint_sets.hpp>
typedef boost::disjoint_sets_with_storage<> UnionFind;
UnionFind uf_n(n);
// Union to elements to the same set
uf_n.union_set(v1, v2);
// Get set of element
uf_n.find_set(v1);
// Check if two elements are in the same set
uf_n.find_set(v1) == uf_n.find_set(v2);
  #+END_SRC
*** Split & List
You can use ~std::map~ and use ~find()~ to search for specific keys. It is
logarithmic, so no need to implement some binary search yourself, just use the
STL.
#+BEGIN_SRC cpp
std::map<int, int> s1, s2;
for(auto s1_itr : s1) {
    // Compute the key
    auto key = smth - s1.first;
    auto s2_itr = s2.find(key);
    if (s2_itr != s2.end()) {
        // key exists! so do something
    }
}
#+END_SRC
